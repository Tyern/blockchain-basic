const Block = require("./block")
const {cryptoHash} = require("../util")
const Transaction = require('../wallet/transaction');
const { REWARD_INPUT, MINING_REWARD } = require('../config');

class Blockchain {
    constructor() {
        this.chain = [Block.genesis()]
    }

    // add new block to current blockchain
    addBlock ({data}) {
        const newBlock = Block.mineBlock({
            lastBlock: this.chain[this.chain.length - 1],
            data: data
        })

        this.chain.push(newBlock)
    }

    // chain validation:
    // - block contain enough info
    // - the last hash connect to the hash of the block came before it
    // - the hash by generated by passing all the info of the block into hash function
    static isValidChain(chain) {
        if (chain.length <= 0) {
            return false
        }

        let chainGenesisJson = JSON.stringify(chain[0])
        let blockGenesisJson = JSON.stringify(Block.genesis())


        if (chainGenesisJson !== blockGenesisJson) {
            return false
        }

        for (let i = 1; i < chain.length; i++) {
            const block = chain[i]
            const actualLastHash = chain[i - 1].hash
            const lastDifficulty = chain[i - 1].difficulty
            const currentDifficulty = block.difficulty

            if (block.lastHash !== actualLastHash) {
                return false
            }

            const validatedHash = cryptoHash(block.timestamp, actualLastHash, block.data, block.nonce, block.difficulty)

            if (block.hash !== validatedHash) {
                return false
            }

            if (Math.abs(lastDifficulty - currentDifficulty) > 1 ) {
                return false 
            }
        }

        return true
    }
    // chain replacement
    // blockchain doesnt exist alone, they link together to form blockchain network
    // get to the unanimous logngest and valid chain
    replaceChain(chain, onSuccess) {
        if (this.chain.length > chain.length) {
            console.log("error:: the incoming chain must be longer")
            return
        }

        if (Blockchain.isValidChain(chain) === false) {
            console.log("error:: the incoming chain must be valid")
            return
        }

        if (onSuccess) onSuccess(); // handle callback
        console.log("replaced chain", chain)
        this.chain = chain
    }

    validTransactionData({ chain }) {
        for (let i=1; i<chain.length; i++) {
            const block = chain[i];
            let rewardTransactionCount = 0;
            for (let transaction of block.data) {
                if (transaction.input.address === REWARD_INPUT.address) {
                    rewardTransactionCount += 1;
                    if (rewardTransactionCount > 1) {
                            console.error('Miner rewards exceeds limit');
                            return false;
                    }
                    if (Object.values(transaction.outputMap)[0] !== MINING_REWARD) {
                            console.error('Miner reward amount is invalid');
                            return false;
                    }
                } else {
                    if (!Transaction.validTransaction(transaction)) {
                            console.error('Invalid transaction');
                            return false;
                    }
                }
            }
        }
        return true;
    }
}


module.exports = Blockchain